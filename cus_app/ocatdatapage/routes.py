"""
Ocat Data Page
==============

**ocatdatapage/routes.py**: Render the Ocat Data Page

:Author: W. Aaron (william.aaron@cfa.harvard.edu)
:Last Updated: Apr 24, 2025


Session Data
------------

* ocat_data_<obsid>: Original state of data in the ocat, specified by obsid
* warning_<obsid>: Warning lines generated by fod.create_warning_line() 
* orient_maps_<obsid>: Hyperlinks to images of observation aimpoint in the RASS, ROSAT, and DSS surveys.
* flag_override_<obsid>: Overriding state of the rank-dependent flags so that information is reduced to Y/N. Corrected in post-processing form the fod.format_POST() function when recording revision.
* ocat_form_dict_<obsid>: Proposed revision of parameters from form edit.
* multi_obsid_<obsid>: Set of additional obsids to perform the revision request on.

"""

import os
import re
import json
from datetime import datetime
import traceback
from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound
from wtforms.validators import ValidationError

from flask import current_app, render_template, request, flash, session, redirect, url_for, abort
from flask_login    import current_user

from cus_app import db
from cus_app.models import register_user, User, Revision, Signoff, Parameter, Request, Original
from cus_app.ocatdatapage import bp
from cus_app.ocatdatapage.forms import ConfirmForm, OcatParamForm
import cus_app.supple.read_ocat_data as rod
import cus_app.supple.database_interface as dbi
import cus_app.ocatdatapage.format_ocat_data as fod


stat_dir =  os.path.join(os.path.dirname(os.path.abspath(__file__)),'..', 'static')
with open(os.path.join(stat_dir, 'labels.json')) as f:
    _LABELS = json.load(f)
with open(os.path.join(stat_dir, 'parameter_selections.json')) as f:
    _PARAM_SELECTIONS = json.load(f)

@bp.before_app_request
def before_request():
    if not current_user.is_authenticated:
        register_user()


@bp.route("/", methods=["GET", "POST"])
@bp.route("/<obsid>", methods=["GET", "POST"])
@bp.route("/index/<obsid>", methods=["GET", "POST"])
def index(obsid=None):
    #
    # --- Fetch all relevant ocat data in it's current state and store in session.
    # --- Note that the 4KB limitation on client-side cookies means we use flask_session to
    # --- integrate server-side cookie directly into the session table of the usint revision SQL database
    #
    if obsid is None or not obsid.isdigit():
        return redirect(url_for('ocatdatapage.provide_obsid'))
    try:
        ocat_data, warning, orient_maps, ocat_form_dict = fetch_session_data(obsid)
    except NoResultFound as e:
        flash("Obsid is not found in the database!")
        return redirect(url_for('ocatdatapage.provide_obsid'))
    except MultipleResultsFound as e:
        flash("Multiple Obsid's found. Please contact Tech and Admin listed at the bottom of the webpage.")
        return redirect(url_for('ocatdatapage.provide_obsid'))
    #
    # --- Render Ocat Data In A WTForm
    #
    form = OcatParamForm(request.form, data = ocat_form_dict)
    if request.method == "POST" and form.is_submitted():
        if form.submit.data:
            if not form.validate():
                #: Form submitted but failed its validation, therefore refresh but display warning message
                for field_name, error_messages in form.errors.items():
                    flash(f"Error in {_LABELS.get(field_name)}: {error_messages}")
            else:
                #: Form submitted, send form data to session and go to confirmation page
                ocat_form_dict = fod.format_POST(form.data)
                session[f'ocat_form_dict_{obsid}'] = ocat_form_dict
                return redirect(url_for('ocatdatapage.confirm', obsid=obsid))
        elif form.refresh.data:
            clear_session_data(obsid)
            return redirect(url_for('ocatdatapage.index', obsid=obsid))
    return render_template("ocatdatapage/index.html", 
                           form=form, 
                           warning=warning,
                           ocat_data=ocat_data,
                           orient_maps=orient_maps,
                           _LABELS=_LABELS)


@bp.route("/confirm/<obsid>", methods=["GET", "POST"])
def confirm(obsid=None):
    #
    # --- Process the selected radio option for the desired change
    #
    form = ConfirmForm(request.form)
    ocat_data, warning, orient_maps, ocat_form_dict = fetch_session_data(obsid)
    #: An original state dictionary is always created and filled. The change request dictionary could be empty if the change is non-norm.
    org_dict, req_dict = fod.construct_entries(ocat_form_dict, ocat_data)
    multi_obsid = create_obsid_list(ocat_form_dict.get('multiobsid'), obsid)
    or_dict = rod.check_obsid_in_or_list([int(obsid)] + multi_obsid)
    is_approved = dbi.is_approved(obsid)
    kind = ocat_form_dict.get("submit_choice")
    if request.method == "POST" and form.is_submitted(): #: no validators
        if form.previous_page.data:
            #: Go back and edit
            return redirect(url_for('ocatdatapage.index', obsid=obsid))
        elif form.finalize.data:
            #: Write changes to the database files
            multi_dict = {'requested': [], 'cannot_request': [], 'unaffected': []}
            try:
                #: Change for the directly-edited obsid
                write_to_database(obsid, ocat_data, kind, org_dict, req_dict)
                #: Changes to the obsids listed in the multi_obsid
                for additional_obsid in multi_obsid:
                    additional_ocat_data = rod.read_ocat_data(additional_obsid)

                    if additional_ocat_data.get('status') in ['scheduled', 'unobserved', 'untriggered']:
                        multi_dict['cannot_request'].append(additional_obsid)
                        continue
                    
                    #: Generate form specific copies of ocat data. Added to ocat data to later change comparison.
                    additional_ocat_data.update(fod.generate_additional(additional_ocat_data))
                    additional_org_dict, additional_req_dict = fod.construct_entries(ocat_form_dict, additional_ocat_data)

                    #: Write the database changes for this new obsid, skipping past incompatible parameter changes.
                    additional_req_dict = {} #: Only want to make changes as confirmed by user. Not infer new ones from construct_entries()
                    if (req_dict.get('instrument') or org_dict.get('instrument')) in ['ACIS-I', 'ACIS-S']:
                        #: Current request involves ACIS
                        if  additional_org_dict.get('instrument')in ['HRC-I', 'HRC-S']:
                            additional_req_dict = {k:v for k,v in req_dict.items() if k not in _PARAM_SELECTIONS['acis_signoff_params']}
                        else:
                            additional_req_dict = req_dict
                    
                    if (req_dict.get('instrument') or org_dict.get('instrument')) in ['HRC-I', 'HRC-S']:
                        #: Current request involves ACIS
                        if  additional_org_dict.get('instrument')in ['ACIS-I', 'ACIS-S']:
                            additional_req_dict = {k:v for k,v in req_dict.items() if k not in ['hrc_timing_mode', 'hrc_zero_block', 'hrc_si_mode']}
                        else:
                            additional_req_dict = req_dict
                    
                    if len(additional_req_dict) == 0:
                        multi_dict['unaffected'].append(additional_obsid)
                        continue

                    multi_dict['requested'].append(additional_obsid)
                    write_to_database(additional_obsid, additional_ocat_data, kind, additional_org_dict, additional_req_dict)
            except Exception as e:  # noqa: E722
                #: In the event of an error, roll back the database session to avoid commits instilled by the server-side cookies
                #: TODO. Do we still clear the session cookies if the database injection failed? I'd assume not...
                db.session.rollback()
                raise e #: TODO replace with abort(500)
            session[f'kind_{obsid}'] = kind
            session[f'multi_dict_{obsid}'] = multi_dict
            return redirect(url_for('ocatdatapage.finalize', obsid=obsid))
    return render_template('ocatdatapage/confirm.html',
                            form = form,
                            obsid = obsid,
                            multi_obsid = multi_obsid,
                            or_dict = or_dict,
                            is_approved = is_approved,
                            kind = kind,
                            org_dict = org_dict,
                            req_dict = req_dict,
                            _LABELS = _LABELS,
                            _PARAM_SELECTIONS = _PARAM_SELECTIONS,
                            _FLAG_RANK_COLUMN_ORDR = fod._FLAG_RANK_COLUMN_ORDR,
                           )

@bp.route('/finalize/<obsid>', methods=['GET', 'POST'])
def finalize(obsid=None):
    """
    If successfully redirected, then the confirmation page's database transactions were successful.
    Therefore, we can clear the Flask-Session server side cookie data for this obsid.
    """
    multi_dict = session.get(f'multi_dict_{obsid}')
    kind = session.get(f"kind_{obsid}")
    clear_session_data(obsid)
    return render_template('ocatdatapage/finalize.html',
                           obsid = obsid,
                           multi_dict = multi_dict,
                           kind = kind
                           )

@bp.route('/provide_obsid', methods=['GET', 'POST'])
def provide_obsid():
    return render_template('ocatdatapage/provide_obsid.html')

def clear_session_data(obsid):
    session.pop(f'ocat_data_{obsid}',None)
    session.pop(f'warning_{obsid}',None)
    session.pop(f'orient_maps_{obsid}',None)
    session.pop(f"flag_override_{obsid}",None)
    session.pop(f'ocat_form_dict_{obsid}',None)
    session.pop(f'multi_dict_{obsid}',None)
    session.pop(f"kind_{obsid}", None)

def fetch_session_data(obsid):
    """
    Possible to get confused midway through a rendering of a form object or storing obsid data
    when working with multiple obsids in a session. This will format them to a specific set related to the input obsid
    """
    ocat_data = session.get(f'ocat_data_{obsid}')
    warning = session.get(f'warning_{obsid}')
    orient_maps = session.get(f'orient_maps_{obsid}')
    flag_override = session.get(f"flag_override_{obsid}")
    if ocat_data is None:
        #: First Fetch
        ocat_data = rod.read_ocat_data(obsid)
        #: Generate form specific copies of ocat data. Added to ocat data to later change comparison.
        form_additions = fod.generate_additional(ocat_data)
        ocat_data.update(form_additions)
        session[f'ocat_data_{obsid}'] = ocat_data
        warning = fod.create_warning_line(ocat_data)
        session[f'warning_{obsid}'] = warning
        orient_maps = fod.create_orient_maps(ocat_data)
        session[f'orient_maps_{obsid}'] = orient_maps
        #
        # --- Create minor overrides for the form display of certain flags
        #
        flag_override = {}
        for flag in ('window_flag', 'roll_flag', 'spwindow_flag'):
            if ocat_data.get(flag) == 'P':
                flag_override[flag] = 'Y'
            elif ocat_data.get(flag) is None:
                flag_override[flag] = 'N'
        session[f'flag_override_{obsid}'] = flag_override
    #
    # --- With the session data related to this specific obsid, we then process whether to 
    # --- generate a new form from the default data or from a previously passed form we are editing again.
    #
    ocat_form_dict = session.get(f'ocat_form_dict_{obsid}', (ocat_data | flag_override))

    return ocat_data, warning, orient_maps, ocat_form_dict

def create_obsid_list(list_string, obsid):
    """
    Create a list of obsids from form input for a parameter display page.
    """
    obsid = int(obsid)
    if list_string is None:
        return []
    list_string = str(list_string)
    if list_string.strip() == '':
        return []
    #: Split the input string into elements
    raw_elements = [x for x in re.split(r'\s+|,|:|;', list_string) if x != '']
    
    #: Combine into string replaceable format for dash parsing
    combined = ','.join(raw_elements)
    combined = combined.replace(',-,','-').replace('-,','-').replace(',-','-')
    
    #: Process Ranges
    obsids_list = []
    for element in combined.split(','):
        if element.isdigit():
            obsids_list.append(int(element))
        else:
            start, end = element.split('-')
            obsids_list.extend(list(range(int(start), int(end) + 1)))
    
    #: Remove duplicates, sort, and exclude the main obsid
    obsids_list = sorted(set(obsids_list) - {obsid})
    return obsids_list

def write_to_database(obsid, ocat_data, kind, org_dict, req_dict={}):
    """
    Perform a set of database injections into the relevant usint.db tables for changes made in the ocatdatapage
    """
    rev = dbi.construct_revision(obsid,ocat_data,kind)
    db.session.add(rev)
    sign = dbi.construct_signoff(rev,req_dict)
    db.session.add(sign)
    orgs = dbi.construct_originals(rev, org_dict)
    for org in orgs:
        db.session.add(org)
    if kind == 'norm':
        reqs = dbi.construct_requests(rev, req_dict)
        for req in reqs:
            db.session.add(req)
    elif kind == 'clone':
        only_comment = {'comments': req_dict.get('comments')}
        reqs = dbi.construct_requests(rev, only_comment)
        for req in reqs:
            db.session.add(req)