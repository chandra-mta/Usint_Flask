"""
Ocat Data Page
==============

**ocatdatapage/routes.py**: Render the Ocat Data Page

:Author: W. Aaron (william.aaron@cfa.harvard.edu)
:Last Updated: Apr 24, 2025


Session Data
------------

* ocat_data_<obsid>: Original state of data in the ocat, specified by obsid
* warning_<obsid>: Warning lines generated by fod.create_warning_line() 
* orient_maps_<obsid>: Hyperlinks to images of observation aimpoint in the RASS, ROSAT, and DSS surveys.
* flag_override_<obsid>: Overriding state of the rank-dependent flags so that information is reduced to Y/N. Corrected in post-processing form the fod.format_POST() function when recording revision.
* ocat_form_dict_<obsid>: Proposed revision of parameters from form edit.
* multi_obsid_<obsid>: Set of additional obsids to perform the revision request on.

"""

import os
import re
import json
from datetime import datetime
import traceback
from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound
from wtforms.validators import ValidationError

from flask import current_app, render_template, request, flash, session, redirect, url_for, abort
from flask_login    import current_user

from cus_app import db
import cus_app.emailing as mail
from cus_app.models import register_user, User, Revision, Signoff, Parameter, Request, Original
from cus_app.ocatdatapage import bp
from cus_app.ocatdatapage.forms import ConfirmForm, OcatParamForm
import cus_app.supple.read_ocat_data as rod
import cus_app.supple.database_interface as dbi
import cus_app.ocatdatapage.format_ocat_data as fod
from cus_app.supple.helper_functions import create_obsid_list, construct_notes, check_obsid_in_or_list


stat_dir =  os.path.join(os.path.dirname(os.path.abspath(__file__)),'..', 'static')
with open(os.path.join(stat_dir, 'labels.json')) as f:
    _LABELS = json.load(f)
with open(os.path.join(stat_dir, 'parameter_selections.json')) as f:
    _PARAM_SELECTIONS = json.load(f)

@bp.before_app_request
def before_request():
    if not current_user.is_authenticated:
        register_user()


@bp.route("/", methods=["GET", "POST"])
@bp.route("/<obsid>", methods=["GET", "POST"])
@bp.route("/index/<obsid>", methods=["GET", "POST"])
def index(obsid=None):
    #
    # --- Fetch all relevant ocat data in it's current state and store in session.
    # --- Note that the 4KB limitation on client-side cookies means we use flask_session to
    # --- integrate server-side cookie directly into the session table of the usint revision SQL database
    #
    if obsid is None or not obsid.isdigit():
        return redirect(url_for('ocatdatapage.provide_obsid'))
    try:
        ocat_data, warning, orient_maps, ocat_form_dict = fetch_session_data(obsid)
    except NoResultFound as e:
        flash("Obsid is not found in the database!")
        return redirect(url_for('ocatdatapage.provide_obsid'))
    except MultipleResultsFound as e:
        flash("Multiple Obsid's found. Please contact Tech and Admin listed at the bottom of the webpage.")
        return redirect(url_for('ocatdatapage.provide_obsid'))
    #
    # --- Render Ocat Data In A WTForm
    #
    form = OcatParamForm(request.form, data = ocat_form_dict)
    if request.method == "POST" and form.is_submitted():
        if form.submit.data:
            if not form.validate():
                #: Form submitted but failed its validation, therefore refresh but display warning message
                for field_name, error_messages in form.errors.items():
                    flash(f"Error in {_LABELS.get(field_name)}: {error_messages}")
            else:
                #: Form submitted, send form data to session and go to confirmation page
                ocat_form_dict = fod.format_POST(form.data)
                session[f'ocat_form_dict_{obsid}'] = ocat_form_dict
                return redirect(url_for('ocatdatapage.confirm', obsid=obsid))
        elif form.refresh.data:
            clear_session_data(obsid)
            return redirect(url_for('ocatdatapage.index', obsid=obsid))
    return render_template("ocatdatapage/index.html", 
                           form=form, 
                           warning=warning,
                           ocat_data=ocat_data,
                           orient_maps=orient_maps,
                           _LABELS=_LABELS)


@bp.route("/confirm/<obsid>", methods=["GET", "POST"])
def confirm(obsid=None):
    #
    # --- Process the selected radio option for the desired change
    #
    form = ConfirmForm(request.form)
    ocat_data, warning, orient_maps, ocat_form_dict = fetch_session_data(obsid)
    #: An original state dictionary is always created and filled. The change request dictionary could be empty if the change is non-norm.
    org_dict, req_dict = fod.construct_entries(ocat_form_dict, ocat_data)
    multi_obsid = create_obsid_list(ocat_form_dict.get('multiobsid'), obsid)
    or_dict = check_obsid_in_or_list([int(obsid)] + multi_obsid)
    is_approved = dbi.is_approved(obsid)
    kind = ocat_form_dict.get("submit_choice")
    able_to_finalize = True
    #
    # --- Specific criteria which prevents the finalize button from being rendered
    #
    if kind == 'clone' and 'comments' not in req_dict:
        flash("Cannot clone obsid without providing comment to explain why.")
        able_to_finalize = False
    if request.method == "POST" and form.is_submitted(): #: no validators
        if form.previous_page.data:
            #: Go back and edit
            return redirect(url_for('ocatdatapage.index', obsid=obsid))
        elif form.finalize.data:
            #: Write changes to the database files
            multi_dict = {'requested': [], 'cannot_request': [], 'unaffected': []}
            try:
                #: Identify Notes
                if kind == 'norm':
                    notes = construct_notes(ocat_data, org_dict, req_dict)
                else:
                    notes = None
                #: Change for the directly-edited obsid
                main_msgs = write_to_database(obsid, ocat_data, kind, notes, org_dict, req_dict)
                #: intermediary variables for multi_obsid emails
                multi_msgs = {k:None for k in multi_obsid}
                multiple_norm_msg = None
                if len(multi_obsid) > 0 and kind == 'norm':
                    multiple_norm_msg = _multi_obsid_msg(obsid, main_msgs, multi_obsid)
                #: Changes to the obsids listed in the multi_obsid
                for additional_obsid in multi_obsid:
                    additional_ocat_data = rod.read_ocat_data(additional_obsid)

                    if additional_ocat_data.get('status') in ['scheduled', 'unobserved', 'untriggered']:
                        multi_dict['cannot_request'].append(additional_obsid)
                        continue
                    
                    #: Generate form specific copies of ocat data. Added to ocat data to later change comparison.
                    additional_ocat_data.update(fod.generate_additional(additional_ocat_data))
                    additional_org_dict, additional_req_dict = fod.construct_entries(ocat_form_dict, additional_ocat_data)

                    #: Write the database changes for this new obsid, skipping past incompatible parameter changes.
                    additional_req_dict = {} #: Only want to make changes as confirmed by user. Not infer new ones from construct_entries()
                    if (req_dict.get('instrument') or org_dict.get('instrument')) in ['ACIS-I', 'ACIS-S']:
                        #: Current request involves ACIS
                        if  additional_org_dict.get('instrument')in ['HRC-I', 'HRC-S']:
                            additional_req_dict = {k:v for k,v in req_dict.items() if k not in _PARAM_SELECTIONS['acis_signoff_params']}
                        else:
                            additional_req_dict = req_dict
                    
                    if (req_dict.get('instrument') or org_dict.get('instrument')) in ['HRC-I', 'HRC-S']:
                        #: Current request involves ACIS
                        if  additional_org_dict.get('instrument')in ['ACIS-I', 'ACIS-S']:
                            additional_req_dict = {k:v for k,v in req_dict.items() if k not in ['hrc_timing_mode', 'hrc_zero_block', 'hrc_si_mode']}
                        else:
                            additional_req_dict = req_dict
                    
                    if len(additional_req_dict) == 0:
                        multi_dict['unaffected'].append(additional_obsid)
                        continue

                    multi_dict['requested'].append(additional_obsid)
                    #: Identify Notes
                    if kind == 'norm':
                        notes = construct_notes(ocat_data, additional_org_dict, additional_req_dict)
                    else:
                        notes = None
                    multi_msgs[additional_obsid] = write_to_database(additional_obsid, additional_ocat_data, kind, notes, additional_org_dict, additional_req_dict)
            except Exception as e:  # noqa: E722
                #: In the event of an error, roll back the database session to avoid commits instilled by the server-side cookies
                #: TODO. Do we still clear the session cookies if the database injection failed? I'd assume not...
                db.session.rollback()
                raise e #: TODO replace with abort(500)
            if main_msgs is not None or main_msgs != []:
                mail.send_msg(main_msgs)
            if multiple_norm_msg is not None:
                mail.send_msg(multiple_norm_msg)
            session[f'kind_{obsid}'] = kind
            session[f'multi_dict_{obsid}'] = multi_dict
            return redirect(url_for('ocatdatapage.finalize', obsid=obsid))
    return render_template('ocatdatapage/confirm.html',
                           able_to_finalize = able_to_finalize,
                            form = form,
                            obsid = obsid,
                            multi_obsid = multi_obsid,
                            or_dict = or_dict,
                            is_approved = is_approved,
                            kind = kind,
                            org_dict = org_dict,
                            req_dict = req_dict,
                            _LABELS = _LABELS,
                            _PARAM_SELECTIONS = _PARAM_SELECTIONS,
                            _FLAG_RANK_COLUMN_ORDR = fod._FLAG_RANK_COLUMN_ORDR,
                           )

@bp.route('/finalize/<obsid>', methods=['GET', 'POST'])
def finalize(obsid=None):
    """
    If successfully redirected, then the confirmation page's database transactions were successful.
    Therefore, we can clear the Flask-Session server side cookie data for this obsid.
    """
    multi_dict = session.get(f'multi_dict_{obsid}')
    kind = session.get(f"kind_{obsid}")
    clear_session_data(obsid)
    return render_template('ocatdatapage/finalize.html',
                           obsid = obsid,
                           multi_dict = multi_dict,
                           kind = kind
                           )

@bp.route('/provide_obsid', methods=['GET', 'POST'])
def provide_obsid():
    return render_template('ocatdatapage/provide_obsid.html')

def clear_session_data(obsid):
    session.pop(f'ocat_data_{obsid}',None)
    session.pop(f'warning_{obsid}',None)
    session.pop(f'orient_maps_{obsid}',None)
    session.pop(f"flag_override_{obsid}",None)
    session.pop(f'ocat_form_dict_{obsid}',None)
    session.pop(f'multi_dict_{obsid}',None)
    session.pop(f"kind_{obsid}", None)

def fetch_session_data(obsid):
    """
    Possible to get confused midway through a rendering of a form object or storing obsid data
    when working with multiple obsids in a session. This will format them to a specific set related to the input obsid
    """
    ocat_data = session.get(f'ocat_data_{obsid}')
    warning = session.get(f'warning_{obsid}')
    orient_maps = session.get(f'orient_maps_{obsid}')
    flag_override = session.get(f"flag_override_{obsid}")
    if ocat_data is None:
        #: First Fetch
        ocat_data = rod.read_ocat_data(obsid)
        #: Generate form specific copies of ocat data. Added to ocat data to later change comparison.
        form_additions = fod.generate_additional(ocat_data)
        ocat_data.update(form_additions)
        session[f'ocat_data_{obsid}'] = ocat_data
        warning = fod.create_warning_line(ocat_data)
        session[f'warning_{obsid}'] = warning
        orient_maps = fod.create_orient_maps(ocat_data)
        session[f'orient_maps_{obsid}'] = orient_maps
        #
        # --- Create minor overrides for the form display of certain flags
        #
        flag_override = {}
        for flag in ('window_flag', 'roll_flag', 'spwindow_flag'):
            if ocat_data.get(flag) == 'P':
                flag_override[flag] = 'Y'
            elif ocat_data.get(flag) is None:
                flag_override[flag] = 'N'
        session[f'flag_override_{obsid}'] = flag_override
    #
    # --- With the session data related to this specific obsid, we then process whether to 
    # --- generate a new form from the default data or from a previously passed form we are editing again.
    #
    ocat_form_dict = session.get(f'ocat_form_dict_{obsid}', (ocat_data | flag_override))

    return ocat_data, warning, orient_maps, ocat_form_dict

def write_to_database(obsid, ocat_data, kind, notes, org_dict, req_dict={}):
    """
    Perform a set of database injections into the relevant usint.db tables for changes made in the ocatdatapage

    :NOTE: Since the style / info / recipients of the notification messages largely depend on information and checks
    performed in the database write setup, we construct the EmailMessage() instances in this algorithmic step and return them upon
    function completion, marking a successfully constructed database transition in the Python SQLAlchemy handling stage.

    Then once the database transactions have all be constructed, we commit them and if we encounter no SQLite level errors, the python code
    continues and uses the EmailMessage() instances to send emails. In this way, we prepare all relevant information but do not accidentally inform
    users of a revision if a transaction error has occurred. The database is also rolled back if a transaction error occurs, which prevents mistakes
    such as writing a revision entry but not writing an accompanying signoff entry.

    :return: Email messages for the proposed revision, using sqlalchemy-related ORMs.
    :rtype: list(EmailMessage())
    """
    rev = dbi.construct_revision(obsid,ocat_data,kind,notes)
    db.session.add(rev)
    sign = dbi.construct_signoff(rev,req_dict)
    db.session.add(sign)
    orgs = dbi.construct_originals(rev, org_dict)
    for org in orgs:
        db.session.add(org)
    if kind == 'norm':
        reqs = dbi.construct_requests(rev, req_dict)
        for req in reqs:
            db.session.add(req)
    elif kind == 'clone':
        only_comment = {'comments': req_dict.get('comments')}
        reqs = dbi.construct_requests(rev, only_comment)
        for req in reqs:
            db.session.add(req)
    msgs = determine_msgs(ocat_data, rev)
    return msgs

def determine_msgs(ocat_data, rev):
    """
    Determine parameter change notification message from input.
    Returns as a list of messages incase multiple are required for a specific revision.

    :return: Email messages for the proposed revision, using sqlalchemy-related ORMs.
    :rtype: list(EmailMessage())

    """
    obsidrev = f"{rev.obsid}.{rev.revision_number:>03}"
    if rev.kind in ('asis, remove'):
        #: Only send to the usint user and CUS email archive when changing the approval state
        return [mail.quick_approval_state_email(ocat_data, obsidrev, rev.kind)]
    elif rev.kind == 'clone':
        #: Notification edge case.
        subject = f"Parameter Change Log: {obsidrev} (Split Request)"
        content = ""
        for param in ('obsid', 'seq_nbr', 'targname'):
            content += f"{_LABELS.get(param)} = {ocat_data.get(param)}\n"
        content += f"User = {current_user.username}\nVERIFIED CLONE\n"
        content += f"PAST COMMENTS = \n{ocat_data.get('comments') or ''}\n\n"
        content += f"NEW COMMENTS = \n{json.loads(rev.request[0].value)}\n\n"
        content += f"PAST REMARKS = \n{ocat_data.get('remarks') or ''}\n\n"
        content += f"Parameter Status Page: {current_app.config['HTTP_ADDRESS']}{url_for('orupdate.index')}\n"
        content += f"Parameter Check Page: {current_app.config['HTTP_ADDRESS']}{url_for('chkupdata.index',obsidrev=obsidrev)}\n"
        return [mail.construct_msg(content, subject, current_user.email, cc =mail.ARCOPS)]
        
    elif rev.kind == 'norm':
        #: Most common type of notification.
        subject = f"Parameter Change Log: {obsidrev}"
        content = ""
        for param in ('obsid', 'seq_nbr', 'targname'):
            content += f"{_LABELS.get(param)} = {ocat_data.get(param)}\n"
        content += f"User = {current_user.username}\nVERIFIED NORM\n"
        #: Prepare formatting for parameter requests, starting with comments and remarks edge case.
        org_dict = {}
        req_dict = {}
        #: Iterate through list of table entries.
        for entry in rev.original:
            org_dict[entry.parameter.name] = json.loads(entry.value)
        for entry in rev.request:
            req_dict[entry.parameter.name] = json.loads(entry.value)

        content += f"PAST COMMENTS = \n{org_dict.get('comments') or ''}\n\n"
        if req_dict.get('comments') is not None:
            content += f"NEW COMMENTS = \n{req_dict.get('comments')}\n\n"
        content += f"PAST REMARKS = \n{ocat_data.get('remarks') or ''}\n\n"
        if req_dict.get('remarks') is not None:
            content += f"NEW REMARKS = \n{req_dict.get('remarks')}\n\n"
        
        gen = set(_PARAM_SELECTIONS['general_signoff_params']).intersection(req_dict.keys())
        acis = (set(_PARAM_SELECTIONS['acis_signoff_params']) - set(_PARAM_SELECTIONS['window_columns'])).intersection(req_dict.keys())
        acis_win = set(_PARAM_SELECTIONS['window_columns']).intersection(req_dict.keys())

        if len(gen) > 0:
            content += "\nGENERAL CHANGES:\n"
            for param in gen:
                content += f"{param.upper()} ({_LABELS.get(param)}) changed from {org_dict.get(param)} to {req_dict.get(param)}\n"
        
        if len(acis) > 0:
            content += "\nACIS CHANGES:\n"
            for param in acis:
                content += f"{param.upper()} ({_LABELS.get(param)}) changed from {org_dict.get(param)} to {req_dict.get(param)}\n"
        
        if len(acis_win) > 0:
            content += "\nACIS WINDOW CHANGES:\n"
            for param in acis_win:
                content += f"{param.upper()} ({_LABELS.get(param)}) changed from {org_dict.get(param)} to {req_dict.get(param)}\n"

        content += f"\nParameter Status Page: {current_app.config['HTTP_ADDRESS']}{url_for('orupdate.index')}\n"
        content += f"Parameter Check Page: {current_app.config['HTTP_ADDRESS']}{url_for('chkupdata.index',obsidrev=obsidrev)}\n"
        #: Use Signoff to determine CC recipients.
        cc = set()
        if rev.signoff.general_status == "Pending":
            cc.add(mail.ARCOPS)
        if rev.signoff.acis_status == "Pending":
            cc.add(mail.ARCOPS)
        if rev.signoff.acis_si_status == "Pending":
            cc.add(mail.ACIS)
        if rev.signoff.hrc_si_status == "Pending":
            cc.add(mail.HRC)
        return [mail.construct_msg(content, subject, current_user.email, cc=cc)]
    
def _multi_obsid_msg(obsid, main_msgs, multi_obsid):
    """
    Parse the main obsid message to create the multi obsid norm change notification.
    """
    _subject = 'Multiple Obsids Are Submitted for Parameter Changes'
    _content = f"Usint User {current_user.username} submitted parameter change requests to multiple obsids: \n\n"
    for _obsid in [obsid] + multi_obsid:
        _obsidrev = f"{_obsid}.{dbi.find_next_rev_no(_obsid):>03}"
        _content += f"{_obsid} : {current_app.config['HTTP_ADDRESS']}{url_for('chkupdata.index',obsidrev = _obsidrev)}\n"
    _content += f"\nUpdated parameters for {obsid} are:\n\n"
    _body = [x for x in main_msgs[0].get_content().split('\n') if x != '']
    _start = 0
    _end = len(_body)
    for i in range(len(_body)):
        if _body[i] in ("GENERAL CHANGES:", "ACIS CHANGES:", "ACIS WINDOW CHANGES:"):
            _start = i
            break
    for i in range(_start, len(_body)):
        if "Parameter Check Page" in _body[i]:
            _end = i
            break
    _content += "\n"+"\n".join(_body[_start:_end])

    return mail.construct_msg(_content, _subject, mail.ARCOPS,)